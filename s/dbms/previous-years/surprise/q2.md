[`üè†`](/) / [`Database Management Systems`](/s/dbms/) / [`Previous Years`](/s/dbms/previous-years/) / [`Surprise`](/s/dbms/previous-years/surprise/) / `Q2`

<hr />

[`MCQs`](/s/dbms/mcqs/)

<hr />

#### Q2A. Find the minimum number of tables required to represent the following ER diagram in relational model

![](https://i.imgur.com/qp0mAtW.png)

```
ACCOUNT (AC_NO, BALANCE) - AC_NO is the primary key.
MANY TO ONE (Account Branch)
BRANCH (B_NAME, B_CITY, ASSETS) - B_NAME is the primary key.

2 tables

----

LOAN (L_NO, AMT) - L_NO is the primary key.
MANY TO ONE (Loan Branch)
BRANCH (B_NAME, B_CITY, ASSETS) - B_NAME is the primary key.

2 tables

----

CUSTOMER (C_CITY, C_NAME, C_STREET) - C_CITY is the primary key.
ONE TO ONE (Borrower)
LOAN (L_NO, AMT) - L_NO is the primary key.

1 table

----

CUSTOMER (C_CITY, C_NAME, C_STREET) 
ONE TO ONE (Depositor)
ACCOUNT (AC_NO, BALANCE)

1 table

TOTAL: 6 tables.
```

Hence a minimum of 6 tables are required to represent the ER diagram.

<hr />

#### Q2B. By definition, pilots are those employees who are certified on at least one aircraft. An aircraft can be used for any flight provided it has sufficient range. Pilots can pilot any flight provided they are certified on an aircraft with sufficient range.

```
Flights(flno, from, to, distance, departs)
Aircraft(aid, aname, range)
Certified(eid, aid)
Employees(eid, ename, salary)
```

**Give relational algebra for following queries.**

1. Find eid‚Äôs of pilots who are certified on some Boeing.

```
œÄ eid (Certified ‚®ù (œÉ aname LIKE '%Boeing%' (Aircraft)))
```

2. Find names of pilots who are certified on some Boeing.

```
œÄ ename (Certified ‚®ù (œÉ aname LIKE '%Boeing%' (Aircraft)))
```

3. Find flno of flights that can be piloted by every pilot whose salary is over $100,000.

```
R1 ‚Üê œÄ eid (œÉ salary > 100000 (Employees ‚®ù Certified))
R2 ‚Üê œÄ eid, aid (Employees ‚®ù Certified))
aids ‚Üê R2 √∑ R1
œÄ flno (œÉ distance ‚â§ range ((Flights, aids) ‚®ù Aircraft)
```

4. Find eid of employee(s) with the highest salary.

```
œÅ(E1, Employees)
œÅ(E2, Employees)
œÅ(E3, œÄ E2.eid (E1 ‚®ù E1.salary>E2.salary E2))
(œÄ eid E1) ‚àí E3
```

5. Find eid of employee(s) with the second highest salary.

```
œÅ(E1, Employees)
œÅ(E2, Employees)
œÅ(E3, œÄE2.eid(E1 ‚®ù E1.salary>E2.salary E2)
œÅ(E4, E2 ‚®ù E3)
œÅ(E5, E2 ‚®ù E3)
œÅ(E6, œÄ E5.eid(E4 ‚®ù E1.salary>E5.salary E5))
(œÄ eid E3) ‚àí E6
```

Sources: http://www.turingmachine.org/courses/2005/csc370K05/assign/db-ch4-2.pdf

<hr />

#### Q2C. Consider a database with the following schema:

```
Person(name, age, gender)        # name is a key
Frequents(name, pizzeria)        # (name, pizzeria) is a key
Eats(name, pizza)                # (name, pizza) is a key
Serves(pizzeria, pizza, price)   # (pizzeria, pizza) is a key
```

**Give SQL queries for following.**

1. Find all pizzerias frequented by at least one person under the age of 18.

```sql
SELECT pizzeria
FROM Frequents, Person
WHERE Frequents.name = Person.name
  AND age < 18;
```

2. Find the names of all females who eat either mushroom or pepperoni pizza (or both).

```sql
SELECT name
FROM Person, Eats
WHERE gender = 'Female'
  AND Eats.pizza IN ('mushroom', 'pepperoni');
```

3. Find the names of all females who eat both mushroom and pepperoni pizza.

```sql
SELECT name
FROM Person, Eats
WHERE gender = 'Female'
  AND Eats.pizza BETWEEN 'mushroom' AND 'pepperoni';
```

4. Find all pizzerias that serve at least one pizza that Amy eats for less than $10.00.

```sql

```

5. Find all pizzerias that are frequented by only females or only males.

<hr />

#### Q2D. Create a trigger that activates when the BEFORE UPDATE event of employee table occurs. And preserve old values in employee_log table with timestamp and userid.

```
employee(eid, ename, post, salary, qualification, doj)
```

<hr />

#### Q2E. Let R = (A, B, C, D, E) be a relation scheme with the following dependencies.

```
AB ‚Üí C
C ‚Üí D
B ‚Üí E
```

**Determine the total number of candidate keys & super keys.**

<hr />

#### Q2F. Consider a relation schema R = (A, B, C, D) with the following functional dependencies.

```
A ‚Üí B
B ‚Üí C
C ‚Üí D
D ‚Üí B
```

**Determine whether the decomposition of R into R1 (A, B), R2 (B, C), R3 (B, D) is lossless or lossy.**

<hr />
